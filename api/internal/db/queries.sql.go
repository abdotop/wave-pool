// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const createCheckoutSession = `-- name: CreateCheckoutSession :exec
INSERT INTO checkout_sessions (
	id,
	amount,
	checkout_status,
	client_reference,
	currency,
	error_url,
	success_url,
	business_name,
	payment_status,
	transaction_id,
	aggregated_merchant_id,
	restrict_payer_mobile,
	enforce_payer_mobile,
	wave_launch_url,
	when_created,
	when_expires,
	when_completed,
	when_refunded,
	last_payment_error_code,
	last_payment_error_message
) VALUES (
	?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateCheckoutSessionParams struct {
	ID                      string
	Amount                  string
	CheckoutStatus          string
	ClientReference         sql.NullString
	Currency                string
	ErrorUrl                string
	SuccessUrl              string
	BusinessName            sql.NullString
	PaymentStatus           string
	TransactionID           sql.NullString
	AggregatedMerchantID    sql.NullString
	RestrictPayerMobile     sql.NullString
	EnforcePayerMobile      sql.NullString
	WaveLaunchUrl           string
	WhenCreated             string
	WhenExpires             string
	WhenCompleted           sql.NullString
	WhenRefunded            sql.NullString
	LastPaymentErrorCode    sql.NullString
	LastPaymentErrorMessage sql.NullString
}

func (q *Queries) CreateCheckoutSession(ctx context.Context, arg CreateCheckoutSessionParams) error {
	_, err := q.db.ExecContext(ctx, createCheckoutSession,
		arg.ID,
		arg.Amount,
		arg.CheckoutStatus,
		arg.ClientReference,
		arg.Currency,
		arg.ErrorUrl,
		arg.SuccessUrl,
		arg.BusinessName,
		arg.PaymentStatus,
		arg.TransactionID,
		arg.AggregatedMerchantID,
		arg.RestrictPayerMobile,
		arg.EnforcePayerMobile,
		arg.WaveLaunchUrl,
		arg.WhenCreated,
		arg.WhenExpires,
		arg.WhenCompleted,
		arg.WhenRefunded,
		arg.LastPaymentErrorCode,
		arg.LastPaymentErrorMessage,
	)
	return err
}

const createSecret = `-- name: CreateSecret :exec

INSERT INTO secrets (
	id, user_id, secret_hash, secret_type, permissions, display_hint, webhook_url, webhook_security_strategy
) VALUES (
	?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateSecretParams struct {
	ID                      string
	UserID                  string
	SecretHash              string
	SecretType              string
	Permissions             string
	DisplayHint             string
	WebhookUrl              sql.NullString
	WebhookSecurityStrategy sql.NullString
}

// Secrets CRUD
func (q *Queries) CreateSecret(ctx context.Context, arg CreateSecretParams) error {
	_, err := q.db.ExecContext(ctx, createSecret,
		arg.ID,
		arg.UserID,
		arg.SecretHash,
		arg.SecretType,
		arg.Permissions,
		arg.DisplayHint,
		arg.WebhookUrl,
		arg.WebhookSecurityStrategy,
	)
	return err
}

const createSession = `-- name: CreateSession :exec

INSERT INTO sessions (
	id, user_id, expires_at
) VALUES (
	?, ?, ?
)
`

type CreateSessionParams struct {
	ID        string
	UserID    string
	ExpiresAt string
}

// Sessions CRUD
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) error {
	_, err := q.db.ExecContext(ctx, createSession, arg.ID, arg.UserID, arg.ExpiresAt)
	return err
}

const createUser = `-- name: CreateUser :exec

INSERT INTO users (
	id, phone_number, pin_hash
) VALUES (
	?, ?, ?
)
`

type CreateUserParams struct {
	ID          string
	PhoneNumber string
	PinHash     string
}

// Users CRUD
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser, arg.ID, arg.PhoneNumber, arg.PinHash)
	return err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM sessions WHERE expires_at <= ?
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context, expiresAt string) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredSessions, expiresAt)
	return err
}

const deleteSecret = `-- name: DeleteSecret :exec
DELETE FROM secrets WHERE id = ?
`

func (q *Queries) DeleteSecret(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSecret, id)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE id = ?
`

func (q *Queries) DeleteSession(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getCheckoutSession = `-- name: GetCheckoutSession :one
SELECT id, amount, checkout_status, client_reference, currency, error_url, success_url, business_name, payment_status, transaction_id, aggregated_merchant_id, restrict_payer_mobile, enforce_payer_mobile, wave_launch_url, when_created, when_expires, when_completed, when_refunded, last_payment_error_code, last_payment_error_message
FROM checkout_sessions
WHERE id = ?
`

func (q *Queries) GetCheckoutSession(ctx context.Context, id string) (CheckoutSession, error) {
	row := q.db.QueryRowContext(ctx, getCheckoutSession, id)
	var i CheckoutSession
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.CheckoutStatus,
		&i.ClientReference,
		&i.Currency,
		&i.ErrorUrl,
		&i.SuccessUrl,
		&i.BusinessName,
		&i.PaymentStatus,
		&i.TransactionID,
		&i.AggregatedMerchantID,
		&i.RestrictPayerMobile,
		&i.EnforcePayerMobile,
		&i.WaveLaunchUrl,
		&i.WhenCreated,
		&i.WhenExpires,
		&i.WhenCompleted,
		&i.WhenRefunded,
		&i.LastPaymentErrorCode,
		&i.LastPaymentErrorMessage,
	)
	return i, err
}

const getCheckoutSessionByTransactionID = `-- name: GetCheckoutSessionByTransactionID :one
SELECT id, amount, checkout_status, client_reference, currency, error_url, success_url, business_name, payment_status, transaction_id, aggregated_merchant_id, restrict_payer_mobile, enforce_payer_mobile, wave_launch_url, when_created, when_expires, when_completed, when_refunded, last_payment_error_code, last_payment_error_message
FROM checkout_sessions
WHERE transaction_id = ?
`

func (q *Queries) GetCheckoutSessionByTransactionID(ctx context.Context, transactionID sql.NullString) (CheckoutSession, error) {
	row := q.db.QueryRowContext(ctx, getCheckoutSessionByTransactionID, transactionID)
	var i CheckoutSession
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.CheckoutStatus,
		&i.ClientReference,
		&i.Currency,
		&i.ErrorUrl,
		&i.SuccessUrl,
		&i.BusinessName,
		&i.PaymentStatus,
		&i.TransactionID,
		&i.AggregatedMerchantID,
		&i.RestrictPayerMobile,
		&i.EnforcePayerMobile,
		&i.WaveLaunchUrl,
		&i.WhenCreated,
		&i.WhenExpires,
		&i.WhenCompleted,
		&i.WhenRefunded,
		&i.LastPaymentErrorCode,
		&i.LastPaymentErrorMessage,
	)
	return i, err
}

const getCheckoutSessionsByClientReference = `-- name: GetCheckoutSessionsByClientReference :many
SELECT id, amount, checkout_status, client_reference, currency, error_url, success_url, business_name, payment_status, transaction_id, aggregated_merchant_id, restrict_payer_mobile, enforce_payer_mobile, wave_launch_url, when_created, when_expires, when_completed, when_refunded, last_payment_error_code, last_payment_error_message
FROM checkout_sessions
WHERE client_reference = ?
`

func (q *Queries) GetCheckoutSessionsByClientReference(ctx context.Context, clientReference sql.NullString) ([]CheckoutSession, error) {
	rows, err := q.db.QueryContext(ctx, getCheckoutSessionsByClientReference, clientReference)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CheckoutSession{}
	for rows.Next() {
		var i CheckoutSession
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.CheckoutStatus,
			&i.ClientReference,
			&i.Currency,
			&i.ErrorUrl,
			&i.SuccessUrl,
			&i.BusinessName,
			&i.PaymentStatus,
			&i.TransactionID,
			&i.AggregatedMerchantID,
			&i.RestrictPayerMobile,
			&i.EnforcePayerMobile,
			&i.WaveLaunchUrl,
			&i.WhenCreated,
			&i.WhenExpires,
			&i.WhenCompleted,
			&i.WhenRefunded,
			&i.LastPaymentErrorCode,
			&i.LastPaymentErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecretByHash = `-- name: GetSecretByHash :one
SELECT id, user_id, secret_hash, secret_type, permissions, display_hint, created_at, revoked_at, webhook_url, webhook_security_strategy FROM secrets WHERE secret_hash = ?
`

func (q *Queries) GetSecretByHash(ctx context.Context, secretHash string) (Secret, error) {
	row := q.db.QueryRowContext(ctx, getSecretByHash, secretHash)
	var i Secret
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SecretHash,
		&i.SecretType,
		&i.Permissions,
		&i.DisplayHint,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.WebhookUrl,
		&i.WebhookSecurityStrategy,
	)
	return i, err
}

const getSecretByID = `-- name: GetSecretByID :one
SELECT id, user_id, secret_hash, secret_type, permissions, display_hint, created_at, revoked_at, webhook_url, webhook_security_strategy FROM secrets WHERE id = ?
`

func (q *Queries) GetSecretByID(ctx context.Context, id string) (Secret, error) {
	row := q.db.QueryRowContext(ctx, getSecretByID, id)
	var i Secret
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SecretHash,
		&i.SecretType,
		&i.Permissions,
		&i.DisplayHint,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.WebhookUrl,
		&i.WebhookSecurityStrategy,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT id, user_id, expires_at, created_at FROM sessions WHERE id = ?
`

func (q *Queries) GetSession(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, phone_number, pin_hash, created_at FROM users WHERE id = ?
`

func (q *Queries) GetUserByID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.PhoneNumber,
		&i.PinHash,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByPhone = `-- name: GetUserByPhone :one
SELECT id, phone_number, pin_hash, created_at FROM users WHERE phone_number = ?
`

func (q *Queries) GetUserByPhone(ctx context.Context, phoneNumber string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByPhone, phoneNumber)
	var i User
	err := row.Scan(
		&i.ID,
		&i.PhoneNumber,
		&i.PinHash,
		&i.CreatedAt,
	)
	return i, err
}

const listCheckoutSessionsByUser = `-- name: ListCheckoutSessionsByUser :many
SELECT id, amount, checkout_status, client_reference, currency, error_url, success_url, business_name, payment_status, transaction_id, aggregated_merchant_id, restrict_payer_mobile, enforce_payer_mobile, wave_launch_url, when_created, when_expires, when_completed, when_refunded, last_payment_error_code, last_payment_error_message
FROM checkout_sessions
ORDER BY when_created DESC 
LIMIT ? OFFSET ?
`

type ListCheckoutSessionsByUserParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) ListCheckoutSessionsByUser(ctx context.Context, arg ListCheckoutSessionsByUserParams) ([]CheckoutSession, error) {
	rows, err := q.db.QueryContext(ctx, listCheckoutSessionsByUser, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CheckoutSession{}
	for rows.Next() {
		var i CheckoutSession
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.CheckoutStatus,
			&i.ClientReference,
			&i.Currency,
			&i.ErrorUrl,
			&i.SuccessUrl,
			&i.BusinessName,
			&i.PaymentStatus,
			&i.TransactionID,
			&i.AggregatedMerchantID,
			&i.RestrictPayerMobile,
			&i.EnforcePayerMobile,
			&i.WaveLaunchUrl,
			&i.WhenCreated,
			&i.WhenExpires,
			&i.WhenCompleted,
			&i.WhenRefunded,
			&i.LastPaymentErrorCode,
			&i.LastPaymentErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSecretsByUser = `-- name: ListSecretsByUser :many
SELECT id, user_id, secret_hash, secret_type, permissions, display_hint, created_at, revoked_at, webhook_url, webhook_security_strategy FROM secrets WHERE user_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListSecretsByUserParams struct {
	UserID string
	Limit  int64
	Offset int64
}

func (q *Queries) ListSecretsByUser(ctx context.Context, arg ListSecretsByUserParams) ([]Secret, error) {
	rows, err := q.db.QueryContext(ctx, listSecretsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Secret{}
	for rows.Next() {
		var i Secret
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SecretHash,
			&i.SecretType,
			&i.Permissions,
			&i.DisplayHint,
			&i.CreatedAt,
			&i.RevokedAt,
			&i.WebhookUrl,
			&i.WebhookSecurityStrategy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsByUser = `-- name: ListSessionsByUser :many
SELECT id, user_id, expires_at, created_at FROM sessions WHERE user_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListSessionsByUserParams struct {
	UserID string
	Limit  int64
	Offset int64
}

func (q *Queries) ListSessionsByUser(ctx context.Context, arg ListSessionsByUserParams) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listSessionsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, phone_number, pin_hash, created_at FROM users ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListUsersParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.PhoneNumber,
			&i.PinHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhooksByUser = `-- name: ListWebhooksByUser :many
SELECT id, user_id, secret_hash, secret_type, permissions, display_hint, created_at, revoked_at, webhook_url, webhook_security_strategy FROM secrets WHERE user_id = ? AND secret_type = 'WEBHOOK_SECRET' ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListWebhooksByUserParams struct {
	UserID string
	Limit  int64
	Offset int64
}

func (q *Queries) ListWebhooksByUser(ctx context.Context, arg ListWebhooksByUserParams) ([]Secret, error) {
	rows, err := q.db.QueryContext(ctx, listWebhooksByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Secret{}
	for rows.Next() {
		var i Secret
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SecretHash,
			&i.SecretType,
			&i.Permissions,
			&i.DisplayHint,
			&i.CreatedAt,
			&i.RevokedAt,
			&i.WebhookUrl,
			&i.WebhookSecurityStrategy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeSecret = `-- name: RevokeSecret :exec
UPDATE secrets SET revoked_at = ? WHERE id = ?
`

type RevokeSecretParams struct {
	RevokedAt sql.NullString
	ID        string
}

func (q *Queries) RevokeSecret(ctx context.Context, arg RevokeSecretParams) error {
	_, err := q.db.ExecContext(ctx, revokeSecret, arg.RevokedAt, arg.ID)
	return err
}

const updateCheckoutSessionRefund = `-- name: UpdateCheckoutSessionRefund :exec
UPDATE checkout_sessions 
SET when_refunded = ?
WHERE id = ?
`

type UpdateCheckoutSessionRefundParams struct {
	WhenRefunded sql.NullString
	ID           string
}

func (q *Queries) UpdateCheckoutSessionRefund(ctx context.Context, arg UpdateCheckoutSessionRefundParams) error {
	_, err := q.db.ExecContext(ctx, updateCheckoutSessionRefund, arg.WhenRefunded, arg.ID)
	return err
}

const updateCheckoutSessionStatus = `-- name: UpdateCheckoutSessionStatus :exec
UPDATE checkout_sessions 
SET checkout_status = ?, when_completed = ?
WHERE id = ?
`

type UpdateCheckoutSessionStatusParams struct {
	CheckoutStatus string
	WhenCompleted  sql.NullString
	ID             string
}

func (q *Queries) UpdateCheckoutSessionStatus(ctx context.Context, arg UpdateCheckoutSessionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateCheckoutSessionStatus, arg.CheckoutStatus, arg.WhenCompleted, arg.ID)
	return err
}

const updateUserPinHash = `-- name: UpdateUserPinHash :exec
UPDATE users SET pin_hash = ? WHERE id = ?
`

type UpdateUserPinHashParams struct {
	PinHash string
	ID      string
}

func (q *Queries) UpdateUserPinHash(ctx context.Context, arg UpdateUserPinHashParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPinHash, arg.PinHash, arg.ID)
	return err
}
