// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: checkout.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCheckoutSession = `-- name: CreateCheckoutSession :one
INSERT INTO checkout_sessions (
    id,
    business_id,
    amount,
    currency,
    client_reference,
    aggregated_merchant_id,
    status,
    error_url,
    success_url,
    restrict_payer_mobile,
    wave_launch_url,
    transaction_id,
    payment_status,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, business_id, amount, currency, client_reference, aggregated_merchant_id, status, error_url, success_url, restrict_payer_mobile, wave_launch_url, transaction_id, payment_status, last_payment_error, expires_at, when_completed, when_created
`

type CreateCheckoutSessionParams struct {
	ID                   string             `json:"id"`
	BusinessID           string             `json:"business_id"`
	Amount               string             `json:"amount"`
	Currency             string             `json:"currency"`
	ClientReference      pgtype.Text        `json:"client_reference"`
	AggregatedMerchantID pgtype.Text        `json:"aggregated_merchant_id"`
	Status               string             `json:"status"`
	ErrorUrl             string             `json:"error_url"`
	SuccessUrl           string             `json:"success_url"`
	RestrictPayerMobile  pgtype.Text        `json:"restrict_payer_mobile"`
	WaveLaunchUrl        pgtype.Text        `json:"wave_launch_url"`
	TransactionID        pgtype.Text        `json:"transaction_id"`
	PaymentStatus        pgtype.Text        `json:"payment_status"`
	ExpiresAt            pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateCheckoutSession(ctx context.Context, arg CreateCheckoutSessionParams) (CheckoutSession, error) {
	row := q.db.QueryRow(ctx, createCheckoutSession,
		arg.ID,
		arg.BusinessID,
		arg.Amount,
		arg.Currency,
		arg.ClientReference,
		arg.AggregatedMerchantID,
		arg.Status,
		arg.ErrorUrl,
		arg.SuccessUrl,
		arg.RestrictPayerMobile,
		arg.WaveLaunchUrl,
		arg.TransactionID,
		arg.PaymentStatus,
		arg.ExpiresAt,
	)
	var i CheckoutSession
	err := row.Scan(
		&i.ID,
		&i.BusinessID,
		&i.Amount,
		&i.Currency,
		&i.ClientReference,
		&i.AggregatedMerchantID,
		&i.Status,
		&i.ErrorUrl,
		&i.SuccessUrl,
		&i.RestrictPayerMobile,
		&i.WaveLaunchUrl,
		&i.TransactionID,
		&i.PaymentStatus,
		&i.LastPaymentError,
		&i.ExpiresAt,
		&i.WhenCompleted,
		&i.WhenCreated,
	)
	return i, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (
    id,
    session_id,
    amount,
    currency,
    status,
    failure_reason
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, session_id, amount, currency, status, failure_reason, completed_at, created_at
`

type CreatePaymentParams struct {
	ID            string      `json:"id"`
	SessionID     string      `json:"session_id"`
	Amount        string      `json:"amount"`
	Currency      string      `json:"currency"`
	Status        string      `json:"status"`
	FailureReason pgtype.Text `json:"failure_reason"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.ID,
		arg.SessionID,
		arg.Amount,
		arg.Currency,
		arg.Status,
		arg.FailureReason,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.FailureReason,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const expireCheckoutSession = `-- name: ExpireCheckoutSession :exec
UPDATE checkout_sessions
SET    status = $2,
       when_completed = $3
WHERE  id = $1
  AND  status = 'open'
`

type ExpireCheckoutSessionParams struct {
	ID            string             `json:"id"`
	Status        string             `json:"status"`
	WhenCompleted pgtype.Timestamptz `json:"when_completed"`
}

func (q *Queries) ExpireCheckoutSession(ctx context.Context, arg ExpireCheckoutSessionParams) error {
	_, err := q.db.Exec(ctx, expireCheckoutSession, arg.ID, arg.Status, arg.WhenCompleted)
	return err
}

const failCheckoutSession = `-- name: FailCheckoutSession :one
UPDATE checkout_sessions
SET    payment_status = 'cancelled',
       last_payment_error = $2
WHERE  id = $1
RETURNING id, business_id, amount, currency, client_reference, aggregated_merchant_id, status, error_url, success_url, restrict_payer_mobile, wave_launch_url, transaction_id, payment_status, last_payment_error, expires_at, when_completed, when_created
`

type FailCheckoutSessionParams struct {
	ID               string `json:"id"`
	LastPaymentError []byte `json:"last_payment_error"`
}

func (q *Queries) FailCheckoutSession(ctx context.Context, arg FailCheckoutSessionParams) (CheckoutSession, error) {
	row := q.db.QueryRow(ctx, failCheckoutSession, arg.ID, arg.LastPaymentError)
	var i CheckoutSession
	err := row.Scan(
		&i.ID,
		&i.BusinessID,
		&i.Amount,
		&i.Currency,
		&i.ClientReference,
		&i.AggregatedMerchantID,
		&i.Status,
		&i.ErrorUrl,
		&i.SuccessUrl,
		&i.RestrictPayerMobile,
		&i.WaveLaunchUrl,
		&i.TransactionID,
		&i.PaymentStatus,
		&i.LastPaymentError,
		&i.ExpiresAt,
		&i.WhenCompleted,
		&i.WhenCreated,
	)
	return i, err
}

const getAPIKeyByPrefixAndSecret = `-- name: GetAPIKeyByPrefixAndSecret :one
SELECT k.id, k.business_id, k.prefix, k.key_hash, k.scopes, k.env, k.status, k.created_at, b.id as business_id_alias, b.name as business_name
FROM api_keys k
JOIN business b ON k.business_id = b.id
WHERE k.prefix = $1 AND k.key_hash = $2
`

type GetAPIKeyByPrefixAndSecretParams struct {
	Prefix  string `json:"prefix"`
	KeyHash string `json:"key_hash"`
}

type GetAPIKeyByPrefixAndSecretRow struct {
	ID              string             `json:"id"`
	BusinessID      string             `json:"business_id"`
	Prefix          string             `json:"prefix"`
	KeyHash         string             `json:"key_hash"`
	Scopes          []string           `json:"scopes"`
	Env             string             `json:"env"`
	Status          pgtype.Text        `json:"status"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	BusinessIDAlias string             `json:"business_id_alias"`
	BusinessName    string             `json:"business_name"`
}

func (q *Queries) GetAPIKeyByPrefixAndSecret(ctx context.Context, arg GetAPIKeyByPrefixAndSecretParams) (GetAPIKeyByPrefixAndSecretRow, error) {
	row := q.db.QueryRow(ctx, getAPIKeyByPrefixAndSecret, arg.Prefix, arg.KeyHash)
	var i GetAPIKeyByPrefixAndSecretRow
	err := row.Scan(
		&i.ID,
		&i.BusinessID,
		&i.Prefix,
		&i.KeyHash,
		&i.Scopes,
		&i.Env,
		&i.Status,
		&i.CreatedAt,
		&i.BusinessIDAlias,
		&i.BusinessName,
	)
	return i, err
}

const getCheckoutSession = `-- name: GetCheckoutSession :one
SELECT id, business_id, amount, currency, client_reference, aggregated_merchant_id, status, error_url, success_url, restrict_payer_mobile, wave_launch_url, transaction_id, payment_status, last_payment_error, expires_at, when_completed, when_created FROM checkout_sessions
WHERE id = $1 AND business_id = $2
`

type GetCheckoutSessionParams struct {
	ID         string `json:"id"`
	BusinessID string `json:"business_id"`
}

func (q *Queries) GetCheckoutSession(ctx context.Context, arg GetCheckoutSessionParams) (CheckoutSession, error) {
	row := q.db.QueryRow(ctx, getCheckoutSession, arg.ID, arg.BusinessID)
	var i CheckoutSession
	err := row.Scan(
		&i.ID,
		&i.BusinessID,
		&i.Amount,
		&i.Currency,
		&i.ClientReference,
		&i.AggregatedMerchantID,
		&i.Status,
		&i.ErrorUrl,
		&i.SuccessUrl,
		&i.RestrictPayerMobile,
		&i.WaveLaunchUrl,
		&i.TransactionID,
		&i.PaymentStatus,
		&i.LastPaymentError,
		&i.ExpiresAt,
		&i.WhenCompleted,
		&i.WhenCreated,
	)
	return i, err
}

const getCheckoutSessionByID = `-- name: GetCheckoutSessionByID :one
SELECT id, business_id, amount, currency, client_reference, aggregated_merchant_id, status, error_url, success_url, restrict_payer_mobile, wave_launch_url, transaction_id, payment_status, last_payment_error, expires_at, when_completed, when_created FROM checkout_sessions
WHERE id = $1
`

func (q *Queries) GetCheckoutSessionByID(ctx context.Context, id string) (CheckoutSession, error) {
	row := q.db.QueryRow(ctx, getCheckoutSessionByID, id)
	var i CheckoutSession
	err := row.Scan(
		&i.ID,
		&i.BusinessID,
		&i.Amount,
		&i.Currency,
		&i.ClientReference,
		&i.AggregatedMerchantID,
		&i.Status,
		&i.ErrorUrl,
		&i.SuccessUrl,
		&i.RestrictPayerMobile,
		&i.WaveLaunchUrl,
		&i.TransactionID,
		&i.PaymentStatus,
		&i.LastPaymentError,
		&i.ExpiresAt,
		&i.WhenCompleted,
		&i.WhenCreated,
	)
	return i, err
}

const getCheckoutSessionByTxID = `-- name: GetCheckoutSessionByTxID :one
SELECT id, business_id, amount, currency, client_reference, aggregated_merchant_id, status, error_url, success_url, restrict_payer_mobile, wave_launch_url, transaction_id, payment_status, last_payment_error, expires_at, when_completed, when_created FROM checkout_sessions
WHERE transaction_id = $1 AND business_id = $2
LIMIT 1
`

type GetCheckoutSessionByTxIDParams struct {
	TransactionID pgtype.Text `json:"transaction_id"`
	BusinessID    string      `json:"business_id"`
}

func (q *Queries) GetCheckoutSessionByTxID(ctx context.Context, arg GetCheckoutSessionByTxIDParams) (CheckoutSession, error) {
	row := q.db.QueryRow(ctx, getCheckoutSessionByTxID, arg.TransactionID, arg.BusinessID)
	var i CheckoutSession
	err := row.Scan(
		&i.ID,
		&i.BusinessID,
		&i.Amount,
		&i.Currency,
		&i.ClientReference,
		&i.AggregatedMerchantID,
		&i.Status,
		&i.ErrorUrl,
		&i.SuccessUrl,
		&i.RestrictPayerMobile,
		&i.WaveLaunchUrl,
		&i.TransactionID,
		&i.PaymentStatus,
		&i.LastPaymentError,
		&i.ExpiresAt,
		&i.WhenCompleted,
		&i.WhenCreated,
	)
	return i, err
}

const searchCheckoutSessions = `-- name: SearchCheckoutSessions :many
SELECT id, business_id, amount, currency, client_reference, aggregated_merchant_id, status, error_url, success_url, restrict_payer_mobile, wave_launch_url, transaction_id, payment_status, last_payment_error, expires_at, when_completed, when_created FROM checkout_sessions
WHERE business_id = $1
  AND client_reference = $2
ORDER BY when_created DESC
`

type SearchCheckoutSessionsParams struct {
	BusinessID      string      `json:"business_id"`
	ClientReference pgtype.Text `json:"client_reference"`
}

func (q *Queries) SearchCheckoutSessions(ctx context.Context, arg SearchCheckoutSessionsParams) ([]CheckoutSession, error) {
	rows, err := q.db.Query(ctx, searchCheckoutSessions, arg.BusinessID, arg.ClientReference)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CheckoutSession
	for rows.Next() {
		var i CheckoutSession
		if err := rows.Scan(
			&i.ID,
			&i.BusinessID,
			&i.Amount,
			&i.Currency,
			&i.ClientReference,
			&i.AggregatedMerchantID,
			&i.Status,
			&i.ErrorUrl,
			&i.SuccessUrl,
			&i.RestrictPayerMobile,
			&i.WaveLaunchUrl,
			&i.TransactionID,
			&i.PaymentStatus,
			&i.LastPaymentError,
			&i.ExpiresAt,
			&i.WhenCompleted,
			&i.WhenCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const succeedCheckoutSession = `-- name: SucceedCheckoutSession :one
UPDATE checkout_sessions
SET    status = 'complete',
       payment_status = 'succeeded',
       when_completed = now()
WHERE  id = $1
RETURNING id, business_id, amount, currency, client_reference, aggregated_merchant_id, status, error_url, success_url, restrict_payer_mobile, wave_launch_url, transaction_id, payment_status, last_payment_error, expires_at, when_completed, when_created
`

func (q *Queries) SucceedCheckoutSession(ctx context.Context, id string) (CheckoutSession, error) {
	row := q.db.QueryRow(ctx, succeedCheckoutSession, id)
	var i CheckoutSession
	err := row.Scan(
		&i.ID,
		&i.BusinessID,
		&i.Amount,
		&i.Currency,
		&i.ClientReference,
		&i.AggregatedMerchantID,
		&i.Status,
		&i.ErrorUrl,
		&i.SuccessUrl,
		&i.RestrictPayerMobile,
		&i.WaveLaunchUrl,
		&i.TransactionID,
		&i.PaymentStatus,
		&i.LastPaymentError,
		&i.ExpiresAt,
		&i.WhenCompleted,
		&i.WhenCreated,
	)
	return i, err
}

const updateCheckoutPaymentStatus = `-- name: UpdateCheckoutPaymentStatus :exec
UPDATE checkout_sessions
SET payment_status = $2
WHERE id = $1 AND business_id = $3
`

type UpdateCheckoutPaymentStatusParams struct {
	ID            string      `json:"id"`
	PaymentStatus pgtype.Text `json:"payment_status"`
	BusinessID    string      `json:"business_id"`
}

func (q *Queries) UpdateCheckoutPaymentStatus(ctx context.Context, arg UpdateCheckoutPaymentStatusParams) error {
	_, err := q.db.Exec(ctx, updateCheckoutPaymentStatus, arg.ID, arg.PaymentStatus, arg.BusinessID)
	return err
}
